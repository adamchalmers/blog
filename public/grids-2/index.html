<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer-when-downgrade">

    <title>Grids in Rust, part 2: const generics</title>
    <meta name="description" content="Thoughts, mostly about tech">

    <link rel="stylesheet" href="https:&#x2F;&#x2F;blog.adamchalmers.com&#x2F;main.css">

    
    <link rel="alternate"
        type="application/atom+xml"
        title="RSS" href="https://blog.adamchalmers.com/atom.xml">
    

    
    
</head>

<body>
    <a class="skip-main" href="#main">Skip to content</a>
    <div class="container">
        <header>
            <h1 class="site-header">
                <a href="https:&#x2F;&#x2F;blog.adamchalmers.com">A Less Mad March</a>
            </h1>
            <nav>
                
                
                
                <a 
                    href="https:&#x2F;&#x2F;blog.adamchalmers.com&#x2F;about&#x2F;">About</a>
                
                
                <a 
                    href="https:&#x2F;&#x2F;blog.adamchalmers.com&#x2F;tags&#x2F;">Tags</a>
                
                
            </nav>
        </header>
        <main id="main" tabindex="-1">
            

<article class="post">
    <header>
        <h1>Grids in Rust, part 2: const generics</h1>
    </header>
    <div class="content">
        <p>In <a href="/grids-1">part one</a>, we defined a Grid trait and implemented it using 1D and 2D vectors. Benchmarks revealed that a 1D vector was a better choice than a nested 2D vector. In this post, we'll write a new implementation that uses arrays instead of Vec. This should be faster!</p>
<span id="continue-reading"></span><h1 id="stack-and-heap">Stack and heap</h1>
<p>When Rust allocates memory for a value, it can allocate on either the stack or the heap. <a href="http://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/the-stack-and-the-heap.html#runtime-efficiency">This page</a> explains the difference between the two, but here's my attempt to summarize</p>
<table><thead><tr><th>?</th><th>Stack</th><th>Heap</th></tr></thead><tbody>
<tr><td>Speed of allocation</td><td>Fast</td><td>Slow</td></tr>
<tr><td>Restrictions</td><td>No pointers, fixed size</td><td>None</td></tr>
</tbody></table>
<p>Data structures that require following pointers go to the heap. Data structures whose layout can be figured out by the compiler at compile-time can go on the stack.</p>
<p>This &quot;stack vs. heap&quot; binary is perfectly represented by &quot;array vs. Vec&quot;. The <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#guarantees">docs</a> state that for a Vec, &quot;the memory it points to is on the heap... and its pointer points to <code>len</code> initialized, contiguous elements in order.&quot; OK, so Vecs inherently use the heap and pointers. This makes them slower than stack-allocated data.</p>
<p>On the other hand, because <a href="https://doc.rust-lang.org/stable/std/primitive.array.html">arrays</a> have a fixed size, the compiler knows exactly how much RAM they require, and can store them on the stack. The downside is that an array type <code>[T; N]</code> has exactly <code>N</code> elements, no more, no less, and you have to know the value of <code>N</code> at compile-time. You can't determine <code>N</code> using user input, or a command-line flag.</p>
<p>Well, it just so happens that for my use-case (a <a href="https://github.com/adamchalmers/raytracer">ray tracer</a>), I know exactly the exact width and height of the grid at compile-time. So I can make a new implementation of Gridlike backed by arrays, not Vecs. There's one little problem, though.</p>
<p>In my binary, I know the exact width and height of the grid at compile-time. But I'd like to have <code>Gridlike</code> trait and its implementations stay in their own reusable library. This means the grids should be able to store any size. After all, there's no point publishing a library with one type for a 2x3 grid, another type for a 2x4 grid, etc. Instead, the Array-based grids should support any width and height, just like the Vec-based grids did. And yet, arrays have to have sizes known at compile time. It seems like these two requirements contradict each other, and until recently, it would have been impossible to satisfy them both. But luckily, Rust just shipped a new feature which enables exactly this sort of requirement.</p>
<h1 id="const-generics">Const generics</h1>
<p>Rust now supports <a href="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta">const generics</a>. You should really read the article to understand what they are, but here's my summary. Traditional generic uses, like <code>Vec&lt;T&gt;</code>, are generic over <em>types</em>. The generic parameter <code>T</code> will always get replaced by a concrete type like <code>i32</code> or <code>String</code> during compilation. When your program is compiled, there's no more <code>T</code>, just <code>Vec&lt;i32&gt;</code> or <code>Vec&lt;String&gt;</code>. For example, this tiny program defines a function named <code>last</code> which is generic over a type <code>T</code>.</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#65737e;">// T could be any type
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">last</span><span style="color:#c0c5ce;">&lt;T&gt;(</span><span style="color:#bf616a;">v</span><span style="color:#c0c5ce;">: Vec&lt;T&gt;) -&gt; Option&lt;T&gt; {
    v.</span><span style="color:#96b5b4;">pop</span><span style="color:#c0c5ce;">()
}

</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#65737e;">// T is replaced with the concrete type &amp;str
    </span><span style="color:#c0c5ce;">assert_eq!(Some(&quot;</span><span style="color:#a3be8c;">world</span><span style="color:#c0c5ce;">&quot;), </span><span style="color:#96b5b4;">last</span><span style="color:#c0c5ce;">(vec![&quot;</span><span style="color:#a3be8c;">hello</span><span style="color:#c0c5ce;">&quot;, &quot;</span><span style="color:#a3be8c;">world</span><span style="color:#c0c5ce;">&quot;]));
    </span><span style="color:#65737e;">// T is replaced with the concrete type bool
    </span><span style="color:#c0c5ce;">assert_eq!(Some(</span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">), </span><span style="color:#96b5b4;">last</span><span style="color:#c0c5ce;">(vec![</span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">, </span><span style="color:#d08770;">false</span><span style="color:#c0c5ce;">]));
}
</span></code></pre>
<p>At compile-time, rustc examines every time <code>last</code> is called, and figures out the right type to substitute for <code>T</code>. The first time it's called, <code>T = &amp;'static str</code>. The next time, <code>T = bool</code>.</p>
<p>Const generics are very similar. But instead of being generic over a <em>type</em>, they're generic over a <em>constant value</em>, like <code>1</code> or <code>33</code> or <code>false</code>. For example, the type <code>[bool; N]</code> is an array of <code>N</code> booleans. When the code is compiled, <code>N</code> will be replaced with some constant value, and the compiler will generate an array with a specific length like <code>[bool: 4]</code>.</p>
<p>Just like how the concrete type <code>T</code> in <code>last&lt;T&gt;</code> had to be known at compile-time, the concrete value for <code>N</code> has to be known at compile-time. In Rust, we call any value that can be calculated at compile-time a <em>constant</em>. Hence, <em>const generics</em>. Let's look at an example:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#65737e;">// T could be any type
// W and H could be any usize value
</span><span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">Grid&lt;T, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> W: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> H: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">&gt;
{
    </span><span style="color:#bf616a;">array</span><span style="color:#c0c5ce;">: [[T; W]; H],
}
</span></code></pre>
<p>Here we define a type <code>Grid</code> with three generic parameters. <code>T</code> is a normal generic over types. <code>W</code> and <code>H</code> are generic over <code>usize</code> values. This means that at compile-time, the grid will have a specific <code>W</code> and <code>H</code> value, and allocate a 2D array with that width and height. <code>T</code>, <code>W</code> and <code>T</code> are generic in the definition of <code>Grid</code>, but will have to be replaced with concrete values at compile-time, just like always with generics.</p>
<h1 id="2d-array-grids-with-const-generics">2D array grids with const generics</h1>
<p>Now that we know how to make a type which is generic over array lengths, let's use it to make a new <code>Gridlike</code> implementation. The constructor for this array-based grid is almost identical to the constructor for the Vec-based grid:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#c0c5ce;">
</span><span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;T, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> W: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> H: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">&gt; Default </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">Grid&lt;T, W, H&gt;
</span><span style="color:#b48ead;">where
</span><span style="color:#c0c5ce;">    T: Default + Copy,
{
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">default</span><span style="color:#c0c5ce;">() -&gt; </span><span style="color:#b48ead;">Self </span><span style="color:#c0c5ce;">{
        </span><span style="color:#b48ead;">Self </span><span style="color:#c0c5ce;">{
            array: [[T::default(); W]; H],
        }
    }
}
</span></code></pre>
<p>How do we actually instantiate this type? It's pretty easy! We just have to ensure the Rust compiler knows what specific values of W and H the binary needs. For example:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> g: Grid&lt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, 3, 4&gt; = Default::default();
</span></code></pre>
<p>Or perhaps:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">const </span><span style="color:#d08770;">WIDTH</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">usize </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">300</span><span style="color:#c0c5ce;">;
</span><span style="color:#b48ead;">const </span><span style="color:#d08770;">HEIGHT</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">usize </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">200</span><span style="color:#c0c5ce;">;
</span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> g: Grid&lt;</span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, WIDTH, HEIGHT&gt; = Default::default();
</span></code></pre>
<p>The <code>Default</code> implementation will be the only constructor we need for this post. You can easily add more constructors if you'd like, maybe <code>fn new(t: T) -&gt; Self</code> that returns a <code>Grid</code> where all cells have the same value <code>t</code>. The <code>Gridlike</code> implementation is also pretty similar:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;T, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> W: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> H: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">&gt; Gridlike&lt;T&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">Grid&lt;T, W, H&gt; {
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">width</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; </span><span style="color:#b48ead;">usize </span><span style="color:#c0c5ce;">{
        W
    }

    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">height</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; </span><span style="color:#b48ead;">usize </span><span style="color:#c0c5ce;">{
        H
    }

    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">p</span><span style="color:#c0c5ce;">: Point) -&gt; &amp;T {
        &amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.array[p.y][p.x]
    }

    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">set_all_parallel</span><span style="color:#c0c5ce;">&lt;F&gt;(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">setter</span><span style="color:#c0c5ce;">: F)
    </span><span style="color:#b48ead;">where
</span><span style="color:#c0c5ce;">        F: Send + Sync + Fn(Point) -&gt; T,
        T: Send,
    {
        </span><span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">rayon::prelude::*;
        </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.array.</span><span style="color:#96b5b4;">par_iter_mut</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">enumerate</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">for_each</span><span style="color:#c0c5ce;">(|(</span><span style="color:#bf616a;">y</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">row</span><span style="color:#c0c5ce;">)| {
            </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">(x, item) in row.</span><span style="color:#96b5b4;">iter_mut</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">enumerate</span><span style="color:#c0c5ce;">() {
                *item = </span><span style="color:#96b5b4;">setter</span><span style="color:#c0c5ce;">(Point { x, y });
            }
        });
    }
}
</span></code></pre>
<p>Note that you can return <code>W</code> in a method (e.g. <code>fn width</code>) as though it were any old <code>usize</code> value. Pretty <em>freakin' sweet</em> in my opinion.</p>
<p>Now, this grid is 2D, and in <a href="/grids-1">part one</a> we found that 2D Vec grids were slower than 1D Vec grids. But they're slow because a 2D vec requires following one pointer per row, which lowers the CPU's cache hit rate. A 2D array doesn't have that problem, because all <code>W*H</code> elements are laid out in memory contiguously. But to get some fair benchmarks, we should try implementing a 1D array-based grid too. This is gonna require some const generics stuff that isn't actually stabilized yet. This means, for the first time in my life, I'm going to have to use... Nightly Rust.</p>
<h1 id="1d-array-grids-with-const-generic-arithmetic">1d array grids with const generic arithmetic</h1>
<p>To get a 1D array which can store all the elements in the grid, we'll need an array of length <code>N</code> where <code>N = W * H</code>. We need to do arithmetic with those const generic values, something like this:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">Grid&lt;T, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> W: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> H: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">&gt;
{
    </span><span style="color:#bf616a;">array</span><span style="color:#c0c5ce;">: [T; W * H],
}
</span></code></pre>
<p>In theory, this should be totally fine. After all, rustc will know the values of <code>W</code> and <code>H</code> at compile-time, and it can certainly multiply two numbers at compile-time. In practice, though, implementing this compiler feature properly (for all types, not just <code>usize</code>) is pretty complicated, as the const generics team explains <a href="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta#const-generics-with-complex-expressions">here</a>. So the feature is still under development. Luckily, we can install an in-development version of the compiler, called &quot;Nightly&quot;, and enable this in-progress feature.</p>
<p>If you haven't installed the Nightly compiler before, don't worry, neither had I until implementing this type! It's easy:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span style="color:#c0c5ce;"> rustup install nightly
</span></code></pre>
<p>And to make sure your current Cargo project uses the Nightly compiler, just run this from inside your project:</p>
<pre style="background-color:#2b303b;">
<code class="language-bash" data-lang="bash"><span style="color:#bf616a;">$</span><span style="color:#c0c5ce;"> rustup override set nightly
</span></code></pre>
<p>Now that we're using the Nightly compiler, we can enable in-progress features (also known as &quot;unstable&quot; features), by adding this to <code>lib.rs</code>:</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#c0c5ce;">#![</span><span style="color:#bf616a;">feature</span><span style="color:#c0c5ce;">(const_evaluatable_checked)]
#![</span><span style="color:#bf616a;">feature</span><span style="color:#c0c5ce;">(const_generics)]
</span></code></pre>
<p>OK, now we can start doing arithmetic with const values. The implementation of the 1D array grid is pretty similar to the 1D vec grid and the 2D array grid. The one strange part is the <code>where</code> clause, but I'll explain that in just a second.</p>
<pre style="background-color:#2b303b;">
<code class="language-rust" data-lang="rust"><span style="color:#b48ead;">use crate</span><span style="color:#c0c5ce;">::{Gridlike, Point};

</span><span style="color:#65737e;">// Define the data structure
</span><span style="color:#b48ead;">pub struct </span><span style="color:#c0c5ce;">Grid&lt;T, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> W: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> H: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">&gt;
where
    [(); W * H]: Sized,
{
    array: [T; W * H],
}

</span><span style="color:#65737e;">// Constructor
</span><span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;T, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> W: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> H: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">&gt; Default </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">Grid&lt;T, W, H&gt;
</span><span style="color:#b48ead;">where
</span><span style="color:#c0c5ce;">    [(); W * H]: Sized,
    T: Default + Copy,
{
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">default</span><span style="color:#c0c5ce;">() -&gt; </span><span style="color:#b48ead;">Self </span><span style="color:#c0c5ce;">{
        </span><span style="color:#b48ead;">Self </span><span style="color:#c0c5ce;">{
            array: [T::default(); W * H],
        }
    }
}

</span><span style="color:#65737e;">// Implement Gridlike
</span><span style="color:#b48ead;">impl</span><span style="color:#c0c5ce;">&lt;T, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> W: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">, </span><span style="color:#b48ead;">const</span><span style="color:#c0c5ce;"> H: </span><span style="color:#b48ead;">usize</span><span style="color:#c0c5ce;">&gt; Gridlike&lt;T&gt; </span><span style="color:#b48ead;">for </span><span style="color:#c0c5ce;">Grid&lt;T, W, H&gt;
</span><span style="color:#b48ead;">where
</span><span style="color:#c0c5ce;">    [(); W * H]: Sized,
{
    </span><span style="color:#65737e;">// Just like the 2D Array
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">width</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; </span><span style="color:#b48ead;">usize </span><span style="color:#c0c5ce;">{
        W
    }

    </span><span style="color:#65737e;">// Just like the 2D Array
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">height</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">) -&gt; </span><span style="color:#b48ead;">usize </span><span style="color:#c0c5ce;">{
        H
    }

    </span><span style="color:#65737e;">// Just like the 1D Vec
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">get</span><span style="color:#c0c5ce;">(&amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">p</span><span style="color:#c0c5ce;">: Point) -&gt; &amp;T {
        &amp;</span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.array[p.y * W + p.x]
    }

    </span><span style="color:#65737e;">// Just like the 1D Vec
    </span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">set_all_parallel</span><span style="color:#c0c5ce;">&lt;F&gt;(&amp;</span><span style="color:#b48ead;">mut </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">setter</span><span style="color:#c0c5ce;">: F)
    </span><span style="color:#b48ead;">where
</span><span style="color:#c0c5ce;">        F: Send + Sync + Fn(Point) -&gt; T,
        T: Send,
    {
        </span><span style="color:#b48ead;">use </span><span style="color:#c0c5ce;">rayon::prelude::*;
        </span><span style="color:#bf616a;">self</span><span style="color:#c0c5ce;">.array.</span><span style="color:#96b5b4;">par_iter_mut</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">enumerate</span><span style="color:#c0c5ce;">().</span><span style="color:#96b5b4;">for_each</span><span style="color:#c0c5ce;">(|(</span><span style="color:#bf616a;">i</span><span style="color:#c0c5ce;">, </span><span style="color:#bf616a;">item</span><span style="color:#c0c5ce;">)| {
            *item = </span><span style="color:#96b5b4;">setter</span><span style="color:#c0c5ce;">(Point { x: i % W, y: i / W });
        });
    }
}
</span></code></pre>
<p>The one weird thing about this is the where clause, <code>where [(); W * H]: Sized</code>. Initially I didn't include that, but then the compiler complained about an &quot;unconstrained generic constant&quot;. I <a href="https://twitter.com/ekuber/status/1372017934910943237">talked to a Rust dev on twitter</a>, and he said that the where clause won't be necessary when this const generic arithmetic feature is finished. It's a bit weird, but hey, the feature is still under development. I'm impressed that it works without panicking, I really don't mind putting an unnecessary where clause in while the Rust team polishes this feature.</p>
<blockquote>
<p>Aside: the Rust core team is so helpful. If I tweet a question to the <a href="twitter.com/rustlang">@rustlang</a> account, they often retweet it so that it gets seen by a dev who can answer. The <a href="https://discord.com/invite/rust-lang">Rust discord</a> is also really helpful. Don't be afraid to ask for help! Everyone is pretty friendly.</p>
</blockquote>
<p>Now that we have 1D and 2D array-based implementations, let's benchmark them.</p>
<h1 id="benchmarks-1d-vs-2d-vec-vs-array">Benchmarks: 1d vs. 2d, Vec vs. array</h1>
<p>Before running the benchmarks, I took a second to make a prediction. My hypothesis was that the array implementations would be faster than the Vec implementations, and that the 1D array would be faster than the 2D array.</p>
<p>The benchmarks themselves are basically identical to the benchmarks from the first part, just with our new array-based implementations added. We're benchmarking each of the 4 Gridlike implementations in three different scenarios (setting all elements, getting elements in order, getting random elements). You can view the <a href="https://github.com/adamchalmers/const_generic_grid/blob/master/benches/my_benchmark.rs">full benchmark code on GitHub</a>. Remember to use <a href="https://docs.rs/criterion/0.3.4/criterion/fn.black_box.html"><code>criterion::black_box</code></a> to avoid the compiler skipping all your code because it (correctly, but unhelpfully) infers that it doesn't actually make any difference to the program output.</p>
<p>The results are <em>pretty close</em> for the Get benchmarks:
<img src="/grids-2/getrandom.png" alt="Benchmark GetRandom" />
<img src="/grids-2/getorder.png" alt="Benchmark GetOrder" /></p>
<p>As for the Set benchmark, well, 2D Vec is so slow that it makes the results basically unreadable.
<img src="/grids-2/set_all.png" alt="Benchmark Set" /></p>
<p>If we recalculate the graph, excluding 2D Vec, it's much easier to read:</p>
<p><img src="/grids-2/set_without_2d_vec.png" alt="Benchmark Set" /></p>
<p><em>Very</em> interesting! 1D array is consistently slower than 2D array. I suspect this is because the 1D array <code>fn set_all_parallel</code> implementation incurs some overhead from translating between 1D and 2D representations. This requires some arithmetic with <code>%</code> and <code>/</code> (the modulo and division operators). On the other hand, it seems the compiler is smart enough to index the 2D array efficiently. And using a 1D array doesn't get the improved performance of cache-hit rates that we saw from 1D vs 2D Vec. Probably because once you're using arrays, everything is stack-allocated.</p>
<p>It's also entirely possible that I've missed some subtlety of benchmarking, and the compiler is optimizing (or failing to optimize) something away. That's why artificial benchmarks are only part of the solution. Real-world results may vary! In fact, in the ray tracer where I use these grids, the only significant difference was that the 2D Vec implementation was slower than the rest. In my specific use-case, the release binary didn't show any improvements between 1D Array, 2D Array and 1D Vec. I ended up using 2D Array in my ray tracer, because the 1D-to-2D translation math was an unnecessary complication.</p>
<p>Thanks for reading! I hope you enjoyed learning about const generics, Nightly Rust and Criterion—I know I did. If you have any questions or suggestions, please let me know on <a href="https://twitter.com/adam_chal">twitter</a> or via <a href="mailto:adam.s.chalmers@gmail.com">email</a>. The code is <a href="https://github.com/adamchalmers/const_generic_grid">on GitHub</a> and if you have suggestions for improving it, feel free to open a PR. Thanks!</p>

    </div>

    
    <div class="article-info">
        
        <div class="article-date">24 March 2021</div>
        
        <div class="article-taxonomies">
            
            
                <ul class="article-tags">
                    
                    <li><a href="https://blog.adamchalmers.com/tags/rust/">#rust</a></li>
                    
                    <li><a href="https://blog.adamchalmers.com/tags/programming/">#programming</a></li>
                    
                </ul>
            
        </div>
    </div>

</article>


        </main>
        <footer>
            <p>
                © A Less Mad March 2021<br>
                Powered by <a target="_blank" href="https://getzola.com/">Zola</a>, Theme <a target="_blank"
                    href="https://github.com/zbrox/anpu">Anpu</a>.
            </p>
            <p>
                
                
            </p>
        </footer>
    </div>
</body>

</html>